---
title: "REST vs GraphQL vs gRPC API 설계"
date: "2025-07-02"
tags: ["네트워크", "CS", "API", "REST", "GraphQL", "gRPC"]
difficulty: "medium"
---

# REST vs GraphQL vs gRPC API 설계

## 1. 핵심 개념 (Core Concept)

**REST, GraphQL, gRPC**는 현대 애플리케이션에서 클라이언트와 서버, 또는 서버 간의 통신을 위해 사용되는 대표적인 API 설계 아키텍처입니다. **REST**는 HTTP 프로토콜을 최대한 활용하는 가장 보편적인 방식이며, **GraphQL**은 클라이언트가 필요한 데이터만 정확하게 요청하는 데 중점을 둔 쿼리 언어 기반 방식입니다. **gRPC**는 마이크로서비스 환경에서 고성능의 서버 간 통신을 위해 구글이 개발한 원격 프로시저 호출(RPC) 시스템입니다.

---

## 2. 상세 설명 (Detailed Explanation)

### 2.1 아키텍처별 특징 비교

| 특징 | REST (Representational State Transfer) | GraphQL (Graph Query Language) | gRPC (Google RPC) |
| :--- | :--- | :--- | :--- |
| **통신 패러다임** | 자원(Resource) 중심, HTTP 메서드로 행위 표현 | 클라이언트 중심, 필요한 데이터 구조를 쿼리 | 원격 함수(프로시저) 호출 |
| **엔드포인트** | 다중 엔드포인트 (e.g., `/users`, `/posts`) | **단일 엔드포인트** (e.g., `/graphql`) | 서비스 및 메서드별로 정의 |
| **데이터 포맷** | JSON, XML 등 (주로 JSON) | JSON | **프로토콜 버퍼 (Protocol Buffers)** - 바이너리 |
| **기반 프로토콜** | HTTP/1.1 | HTTP/1.1 | **HTTP/2** |
| **데이터 요청 효율성** | **Over/Under-fetching** 발생 가능 | 필요한 데이터만 정확히 요청 가능 | 효율적인 바이너리 직렬화, 스트리밍 |
| **스트리밍** | 미지원 | 단방향(Subscription) 지원 | **양방향(Bi-directional)** 지원 |
| **스키마/타입 정의** | 별도 표준 없음 (OpenAPI/Swagger 사용) | **강력한 타입 시스템 (SDL)** | **프로토콜 버퍼 (.proto 파일)** |

### 2.2 아키텍처별 장단점

#### 가. REST

*   **장점**:
    *   **단순함과 직관성**: HTTP 기반으로 동작하여 이해하고 사용하기 쉽습니다.
    *   **높은 범용성**: 웹 표준을 따르므로 대부분의 클라이언트에서 별도 라이브러리 없이 사용 가능합니다.
    *   **캐싱 용이성**: `GET` 메서드를 활용한 HTTP 캐싱 메커니즘을 쉽게 적용할 수 있습니다.
*   **단점**:
    *   **Over-fetching / Under-fetching**: 서버가 정의한 고정된 데이터 구조로만 응답하므로, 클라이언트가 필요 없는 정보까지 받거나(Over-fetching), 원하는 정보를 얻기 위해 여러 번 요청해야 하는(Under-fetching) 문제가 발생합니다.
    *   **엔드포인트 관리**: 기능이 복잡해질수록 엔드포인트 수가 증가하여 관리가 어려워질 수 있습니다.

#### 나. GraphQL

*   **장점**:
    *   **데이터 호출 효율성**: 클라이언트가 필요한 데이터만 정확하게 요청하여 네트워크 사용량을 최적화합니다.
    *   **클라이언트 중심 개발**: 프론트엔드에서 필요한 데이터 구조를 직접 정의할 수 있어 개발 유연성이 높습니다.
    *   **강력한 타입 시스템**: 스키마를 통해 API 명세가 명확해지고, 개발 과정에서 오류를 줄일 수 있습니다.
*   **단점**:
    *   **학습 곡선**: REST에 비해 새로운 개념과 쿼리 언어를 학습해야 합니다.
    *   **복잡한 쿼리 처리**: 중첩된 복잡한 쿼리가 서버에 부하를 줄 수 있어, 이를 방지하기 위한 추가적인 구현(e.g., 쿼리 깊이 제한)이 필요합니다.
    *   **캐싱의 어려움**: 주로 `POST` 요청을 사용하므로 HTTP 레벨에서의 캐싱 구현이 복잡합니다.

#### 다. gRPC

*   **장점**:
    *   **고성능**: 프로토콜 버퍼를 사용한 바이너리 직렬화   HTTP/2의 멀티플렉싱을 통해 매우 빠른 통신이 가능합니다.
    *   **양방향 스트리밍**: 클라이언트와 서버가 지속적으로 데이터를 주고받는 실시간 통신에 매우 유리합니다.
    *   **엄격한 타입 안정성**: `.proto` 파일로 서비스 인터페이스와 메시지 타입을 명확하게 정의하여 개발 과정에서의 오류를 줄일 수 있습니다.
*   **단점**:
    *   **브라우저 지원 제한**: 브라우저에서 직접 사용하기 위해서는 gRPC-Web과 같은 별도의 프록시가 필요합니다.
    *   **낮은 가독성**: 프로토콜 버퍼는 바이너리 포맷이므로 사람이 직접 읽고 디버깅하기 어렵습니다.
    *   **제한적인 생태계**: REST에 비해 상대적으로 커뮤니티나 자료가 적을 수 있습니다.

---

## 3. 예시 (Example)

### 사용 사례 (Use Case)

**"사용자 ID가 1인 유저의 이름과 그가 작성한 글들의 제목 가져오기"**

#### REST

1.  `GET /users/1` 요청 -> 사용자 정보(이름, 이메일, 주소 등)를 받음.
2.  `GET /users/1/posts` 요청 -> 해당 사용자가 작성한 글 목록(제목, 내용, 작성일 등)을 받음.
    *   **문제점**: 필요 없는 정보(이메일, 주소, 글 내용 등)까지 받게 되고(Over-fetching), 두 번의   청이 필요함(Under-fetching).

#### GraphQL

하나의 엔드포인트(`POST /graphql`)에 아래와 같은 쿼리를 전송:

```graphql
query {
  user(id: "1") {
    name
    posts {
      title
    }
  }
}
```

*   **결과**: 딱 필요한 `name`과 `posts`의 `title`만 포함된 JSON 객체를 한 번의 요청으로 받아옴.

#### gRPC

1.  `.proto` 파일에 서비스와 메시지 정의:
    ```protobuf
    syntax = "proto3";

    service UserService {
      rpc GetUserWithPosts(UserRequest) returns (UserWithPosts);
    }

    message UserRequest {
      string id = 1;
    }

    message Post {
      string title = 1;
    }

    message UserWithPosts {
      string name = 1;
      repeated Post posts = 2;
    }
    ```
2.  클라이언트에서 생성된 코드를 통해 원격 함수 호출: `client.GetUserWithPosts(UserRequest(id="1"))`
    *   **결과**: 프로토콜 버퍼로 직렬화된 바이너리 데이터를 받아와서 `UserWithPosts` 객체로 역직렬화하여 사용.

---

## 4. 예상 면접 질문 (Potential Interview Questions)

*   **Q. REST API의 Over-fetching과 Under-fetching 문제를 설명하고, GraphQL이 이를 어떻게 해결하는지 설명해주세요.**
    *   **A.** Over-fetching은 서버가 고정된 데이터만 응답하여 클라이언트가 필요 없는 정보까지 받는 것이고, Under-fetching은 원하는 정보를 얻기 위해 여러 번의 API 호출이 필요한 상황입니다. GraphQL은 클라이언트가 쿼리를 통해 필요한 데이터의 구조를 직접 명시하여 요청하므로, 서버는 정확히 그 구조에 맞는 데이터만 응답해줍니다. 이로써 단 한 번의 요청으로 원하는 모든 정보를, 불필요한 데이터 없이 받아올 수 있어 두 문제를 모두 해결합니다.

*   **Q. gRPC가 REST에 비해 성능상 이점을 가지는 이유는 무엇인가요?**
    *   **A.** 두 가지 핵심적인 이유가 있습니다. 첫째, gRPC는 **HTTP/2**를 기반으로 동작하여 하나의 커넥션으로 여러 메시지를 동시에 주고받는 '멀티플렉싱'과 '헤더 압축' 등을 지원합니다. 둘째, JSON이나 XML 같은 텍스트 기반 포맷 대신, 바이너리 기반의 **프로토콜 버퍼(Protocol Buffers)**를 사용하여 데이터를 직렬화합니다. 바이너리 데이터는 크기가 작고 파싱 속도가 빨라 네트워크 대역폭을 절약하고 CPU 사용량을 줄여주므로 훨씬 높은 성능을 보입니다.

*   **Q. 어떤 상황에서 REST, GraphQL, gRPC를 각각 사용하는 것이 적합할까요?**
    *   **A.** **REST**는 외부 개발자에게 제공하는 공개 API나, 간   한 CRUD 중심의 웹 서비스처럼 **범용성과 단순성**이 중요할 때 적합합니다. **GraphQL**은 다양한 종류의 클라이언트(모바일, 웹 등)가 존재하거나, 화면마다 필요한 데이터가 크게 달라 **유연한 데이터 요청**이 중요할 때 유리합니다. **gRPC**는 마이크로서비스 아키텍처처럼 여러 백엔드 서비스 간의 **고성능 통신**이 필수적이거나, 실시간 스트리밍이 필요할 때 최적의 선택입니다.

---

## 5. 더 읽어보기 (Further Reading)

*   [REST API (IBM Developer)](https://www.ibm.com/topics/rest-apis)
*   [GraphQL 공식 문서](https://graphql.org/)
*   [gRPC 공식 문서](https://grpc.io/)