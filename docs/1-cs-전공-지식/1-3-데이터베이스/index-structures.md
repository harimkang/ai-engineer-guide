---
title: "인덱스 구조 (B-Tree, 해시 인덱스, 역색인)"
date: "2025-07-02"
tags: ["데이터베이스", "CS", "인덱스", "B-Tree", "해시", "역색인"]
difficulty: "medium"
---

# 인덱스 구조 (B-Tree, 해시 인덱스, 역색인)

## 1. 핵심 개념 (Core Concept)

**인덱스(Index)**는 데이터베이스 테이블에 대한 검색 성능을 향상시키기 위한 자료구조입니다. 책의 맨 뒤에 있는 '찾아보기'처럼, 인덱스는 특정 데이터를 어디서 찾아야 하는지에 대한 정보를 담고 있어 전체 테이블을 스캔하는 수고를 덜어줍니다. 데이터베이스는 **B-Tree, 해시 인덱스, 역색인** 등 다양한 인덱스 구조를 사용하여, 각기 다른 유형의 쿼리 성능을 최적화합니다.

---

## 2. 상세 설명 (Detailed Explanation)

### 2.1 B-Tree / B+Tree

B-Tree(Balanced Tree)는 자식 노드를 2개 이상 가질 수 있는 균형 잡힌 트리 구조로, 데이터베이스 인덱스에서 가장 보편적으로 사용됩니다. **B+Tree**는 B-Tree를 개선한 자료구조로, 현재 대부분의 관계형 데이터베이스(MySQL의 InnoDB 등)에서 표준 인덱스 구조로 채택하고 있습니다.

#### B+Tree 구조 및 특징
```mermaid
graph TD;
    subgraph "B+Tree"
        Root --> Branch1;
        Root --> Branch2;
        Branch1 --> L1 & L2;
        Branch2 --> L3 & L4;
    end

    subgraph "Nodes"
        Root("Root<br>(Keys Only)")
        Branch1("Branch<br>(Keys Only)")
        Branch2("Branch<br>(Keys Only)")
        L1("Leaf<br>(Keys + Data Pointers)")
        L2("Leaf<br>(Keys + Data Pointers)")
        L3("Leaf<br>(Keys + Data Pointers)")
        L4("Leaf<br>(Keys + Data Pointers)")
    end
    
    L1 <--> L2 <--> L3 <--> L4;
    note for L1,L2,L3,L4 "리프 노드는 Linked List로 연결"
```

*   **구조**:
    *   **브랜치 노드 (Root, Branch)**: 데이터의 위치를 찾아가기 위한 **Key(인덱스 컬럼 값)만** 저장합니다.
    *   **리프 노드 (Leaf)**: **Key와 실제 데이터의 주소값(Data Pointer)을 함께** 저장합니다. 모든 데이터는 리프 노드에만 존재합니다.
    *   **연결 리스트**: 리프 노드들은 **양방향 연결 리스트(Doubly Linked List)**로 서로 연결되어 있습니   .
*   **장점**:
    *   **효율적인 범위 검색**: 리프 노드들이 연결되어 있어, 특정 지점에서 순차적으로 연결된 노드들을 탐색하면 되므로 범위 검색(`BETWEEN`, `>`) 성능이 매우 뛰어납니다.
    *   **안정적인 검색 속도**: 어떤 값을 조회하든 항상 트리의 높이만큼의 시간 복잡도(O(logN))를 보장합니다.
*   **단점**: 데이터 변경(INSERT, UPDATE, DELETE) 시 트리의 균형을 맞추기 위한 재정렬 작업으로 인한 오버헤드가 발생할 수 있습니다.

### 2.2 해시 인덱스 (Hash Index)

해시 인덱스는 해시 함수를 사용하여 Key를 해시 값으로 변환하고, 이 해시 값을 인덱스로 사용하여 데이터에 직접 접근하는 방식입니다.

*   **구조**: 해시 테이블(Hash Table) 자료구조를 사용하며, Key와 데이터 포인터를 버킷(Bucket)에 저장합니다.
*   **장점**:
    *   **매우 빠른 검색 속도**: 등호(`=`)를 사용한 동등 비교 검색에서 **O(1)**이라는 매우 빠른 속도를 보입니다.
*   **단점**:
    *   **범위 검색 불가**: 해시 함수는 Key를 무작위적으로 변환하므로, 데이터가 정렬되어 있지 않아 범위 검색이나 부등호 연산(`>`, `<`)을 사용할 수 없습니다.
    *   **해시 충돌(Hash Collision)**: 서로 다른 Key가 같은 해시 값으로 변환되는 해시 충돌이 발생하면 검색 성능이 저하될 수 있습니다.

### 2.3 역색인 (Inverted Index)

역색인은 '책의 맨 뒤에 있는 찾아보기'와 유사한 개념으로, 키워드를 통해 해당 키워드가 포함된 문서를 찾아내는 방식입니다. 주로 **전문 검색(Full-text Search)** 엔진(예: Elasticsearch, Solr)에서 사용됩니다.

*   **구조**: 문서의 내용을 단어(Term 또는 Token) 단위로 분리하고, 각 단어가 어떤 문서에 등장하는지를 매핑하는 형태로 구성됩니다.
    *   **Term Dictionary**: 모든 고유한 단어(Term)들의 집합.
    *   **Postings List**: 각 단어가 나타나는 문서들의 ID와 위치 정보 목록.

| Term | Document IDs |
| :--- | :--- |
| 데이터베이스 | Doc1, Doc3 |
| 인덱스 | Doc1, Doc2, Doc3 |
| 검색 | Doc2 |

*   **장점**: 특정 키워드가 포함된 문서를 매우 빠르게 찾아낼 수 있어, 대용량의 비정형 텍스트 데이터 검색에 매우 효과적입니다.
*   **단점**: 데이터가 추가되거나 변경될 때마다 역색인을 다시 생성해야 하므로, 데이터 변경이 잦은 환경에는 부담이 될 수 있습니다.

---

## 3. 예시 (Example)

### 사용 사례별 인덱스 선택

*   **회원 정보 테이블의 `user_id` 컬럼**:
    *   **B+Tree 인덱스**가 적합합니다. `user_id`로 특정 회원을 조회(`=`)하는 것은 물론, 특정 ID 범위의 회원들을 조회(`BETWEEN`)하는 경우가 많기 때문입니다.
*   **URL 원본을 저장하고 중복을 확인하는 테이블**:
    *   **해시 인덱스**가 적합할 수 있습니다. 항상 전체 URL이 일치하는지(`=`) 확인하는 동등 비교만 수행하므로, B+Tree보다 빠른 조회가 가능합니다.
*   **블로그 게시물의 내용(본문) 검색**:
    *   **역색인**이 필수적입니다. 사용자가 "데이터베이스 인덱스"라는 키워드로 검색했을 때, 본문에 두 단어가 모두 포함된 게시물을 빠르게 찾아주기 때문입니다.

---

## 4. 예상 면접 질문 (Potential Interview Questions)

*   **Q. B-Tree와 B+Tree의 가장 큰 차이점은 무엇이며, 왜 데이터베이스에서는 주로 B+Tree를 사용하나요?**
    *   **A.** 가장 큰 차이점은 **데이터 저장 위치**와 **리프 노드의 연결 구조**입니다. B-Tree는 모든 노드에 데이터 포인터를 저장하지만, B+Tree는 오직 리프 노드에만 저장합니다. 또한, B+Tree의 리프 노드들은 서로 연결 리스트로 연결되어 있습니다. 이 구조 덕분에 B+Tree는 특정 범위의 데이터를 조회할 때 리프 노드만 순차적으로 스캔하면 되므로 **범위 검색 성능이 매우 뛰어납니다.** 데이터베이스에서는 범위 검색이 빈번하게 일어나므로 B+Tree가 더 효율적입니다.

*   **Q. 해시 인덱스는 검색 속도가 O(1)로 매우 빠름에도 불구하고 왜 B+Tree 인덱스가 더 보편적으로 사용되나요?**
    *   **A.** 해시 인덱스는 등호(`=`)를 사용한 동등 비교 검색에만 강점을 가질 뿐, 부등호(`>`, `<`)나 `BETWEEN`을 사용한 **범위 검색이 불가능**하기 때문입니다. 데이터베이스 쿼리는 특정 값 하나만 찾는 경우보다 특정 범위를 찾는 경우가 훨씬 많으므로, 범위 검색에 효율적인 B+Tree가 범용적으로 더 적합합니다.

*   **Q. 역색인(Inverted Index)은 어떤 종류의 데이터를 검색할 때 사용되며, 어떤 원리로 동작하나요?**
    *   **A.** 역색인은 주로 **전문(Full-text) 검색**, 즉 대량의 텍스트 데이터 내에서 특정 단어나 구문이 포함된 문서를 찾을 때 사용됩니다. 원리는 책의 '찾아보기'와 같습니다. 먼저 문서 내의 모든 단어를 추출하여 '단어 사전(Term Dictionary)'을 만들고, 각 단어가 어떤 문서에 등장하는지에 대한 정보 목록('Postings List')을 만듭니다. 사용자가 키워드로 검색하면, 단어 사전을 통해 즉시 해당 키워드가 포함된 문서 목록을 찾아낼 수 있어 매우 빠른 검색이 가능합니다.

---

## 5. 더 읽어보기 (Further Reading)

*   [B+Tree | Set 1 (Introduction) (GeeksforGeeks)](https://www.geeksforgeeks.org/b-tree-set-1-introduction-2/)
*   [Hash Indexing (Wikipedia)](https://en.wikipedia.org/wiki/Hash_index)
*   [What is an Inverted Index? (Elastic)](https://www.elastic.co/what-is/inverted-index)