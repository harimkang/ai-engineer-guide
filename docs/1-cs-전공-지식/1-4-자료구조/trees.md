---
title: "트리 (BST, AVL, Red-Black, B-Tree)"
date: "2025-07-02"
tags: ["자료구조", "CS", "트리", "BST", "AVL", "RedBlackTree", "BTree"]
difficulty: "medium"
---

# 트리 (BST, AVL, Red-Black, B-Tree)

## 1. 핵심 개념 (Core Concept)

**트리(Tree)**는 노드(Node)와 간선(Edge)으로 이루어진 **계층적 비선형 자료구조**입니다. **이진 탐색 트리(BST)**는 탐색 효율을 높인 이진 트리이며, 여기서 발생할 수 있는 편향 문제를 해결하기 위해 **AVL 트리**와 **레드-블랙 트리** 같은 **자가 균형(Self-Balancing)** 이진 탐색 트리가 등장했습니다. **B-트리**는 이진 트리를 확장하여 하나의 노드가 2개 이상의 자식을 가질 수 있도록 일반화한 트리 구조로, 주로 데이터베이스와 파일 시스템에서 사용됩니다.

---

## 2. 상세 설명 (Detailed Explanation)

### 2.1 이진 탐색 트리 (Binary Search Tree, BST)

이진 트리의 일종으로, 데이터를 효율적으로 탐색하기 위해 다음과 같은 규칙을 따릅니다.
*   **규칙**:
    *   각 노드의   쪽 서브트리에는 해당 노드의 값보다 **작은** 값들만 존재합니다.
    *   각 노드의 오른쪽 서브트리에는 해당 노드의 값보다 **큰** 값들만 존재합니다.
    *   모든 서브트리 역시 이진 탐색 트리입니다.
*   **장점**: 평균적으로 O(log n)의 빠른 탐색, 삽입, 삭제 시간을 가집니다.
*   **단점**: 데이터가 정렬된 순서로 입력되면 트리가 한쪽으로 치우쳐진 **편향 트리(Skewed Tree)**가 되어, 탐색 성능이 최악의 경우 O(n)으로 저하될 수 있습니다.

### 2.2 자가 균형 이진 탐색 트리 (Self-Balancing BST)

BST의 편향 문제를 해결하기 위해, 삽입/삭제 시 스스로 균형을 맞추는 트리들입니다.

#### 가. AVL 트리 (Adelson-Velsky and Landis Tree)
*   **특징**: 모든 노드에서 왼쪽 서브트리와 오른쪽 서브트리의 **높이 차이(Balance Factor)가 최대 1 이하**로 유지됩니다.
*   **균형 조정**: 삽입 또는 삭제 시 트리의 균형이 깨지면, **회전(Rotation)**을 통해 균형을 맞춥니다.
*   **장점**: 항상 엄격하게 균형을 유지하므로 탐색 성능이 O(log n)으로 보장됩니다.
*   **단점**: 균형을 엄격하게 유지하기 때문에 삽입/삭제 시 회전이 빈번하게 발생할 수 있어, 삽입/삭제가 잦은 환경에서는 비효율적일 수 있습니다.

#### 나. 레드-블랙 트리 (Red-Black Tree)
*   **특징**: 노드에 **색상(Red 또는 Black)**을 부여하고, 특정 규칙에 따라 균형을 유지합니다.
    1.  모든 노드는 Red 또는 Black.
    2.  루트 노드는 Black.
    3.  모든 리프 노드(NIL)는 Black.
    4.  Red 노드의 자식은 반드시 Black (연속된 Red 노드 없음).
    5.  임의의 노드에서부터 그 자손인 리프 노드까지의 모든 경로에는 동일한 개수의 Black 노드가 존재.
*   **균형 조정**: 색상 변경과 회전을 통해 균형을 맞춥니다.
*   **장점**: AVL 트리보다 균형을 덜 엄격하게 유지하여 **삽입/삭제 시 회전이 덜 발생**할 수 있습니다. 따라서 삽입/삭제가 빈번한 경우 AVL 트리보다 효율적입니다.
*   **단점**: AVL 트리보다 트리의 높이가 약간 더 높아질 수 있어 탐색 성능은 미세하게 떨어질 수 있습니다.

### 2.3 B-트리 (B-Tree)

B-트리는 이진 트리를 확장하여 하나의 노드가 2개 이상의 자식 노드를 가질 수 있도록 일반화한 트리 구조입니다.

*   **특징**:
    *   하나의 노드에 여러 개의 데이터를 저장할 수 있으며, 데이터는 항상 정렬된 상태를 유지합니다.
    *   모든 리프   드는 같은 레벨에 존재하여 균형을 유지합니다.
*   **목적**: **디스크 접근 횟수를 줄여 성능을 향상**시키는 것이 주 목적입니다. 디스크 I/O는 메모리 접근보다 매우 느리기 때문에, 하나의 노드에 많은 데이터를 저장하여 트리의 높이를 낮게 유지하는 것이 중요합니다.
*   **사용처**: 대용량의 데이터를 처리해야 하는 **데이터베이스 인덱스**나 **파일 시스템**에서 주로 사용됩니다. (B+Tree는 B-Tree의 변형으로, 데이터베이스 인덱스에 더 최적화되어 있습니다.)

### 2.4 비교 요약

| 구분 | 이진 탐색 트리 (BST) | AVL 트리 | 레드-블랙 트리 | B-트리 |
| :--- | :--- | :--- | :--- | :--- |
| **균형 유지** | X | O (엄격함) | O (느슨함) | O |
| **탐색 시간** | 평균 O(log n), 최악 O(n) | O(log n) | O(log n) | O(log n) |
| **삽입/삭제 시간** | 평균 O(log n), 최악 O(n) | O(log n) | O(log n) | O(log n) |
| **주요 특징** | 구현 간단, 편향 가능성 | 빠른 탐색, 엄격한 균형 | **삽입/삭제 빈번시 유리** | **디스크 기반 DB/파일시스템** |
| **구조** | 이진 트리 | 균형 잡힌 이진 트리 | 균형 잡힌 이진 트리 | **다차원 트리** |

---

## 3. 예시 (Example)

### 사용 사례별 트리 선택

*   **  순한 데이터 색인**: 데이터의 삽입/삭제가 거의 없고, 데이터 분포가 무작위적이라면 구현이 간단한 **BST**를 사용할 수 있습니다.
*   **탐색 성능이 매우 중요한 경우**: 데이터의 삽입/삭제보다 탐색 연산이 훨씬 빈번하게 일어나는 경우, 항상 최적의 탐색 성능을 보장하는 **AVL 트리**가 적합할 수 있습니다.
*   **삽입/삭제가 빈번한 실시간 데이터 처리**: 실시간으로 데이터가 계속 추가되고 삭제되는 환경에서는 삽입/삭제 오버헤드가 적은 **레드-블랙 트리**가 더 효율적입니다. (Java의 `TreeMap`, C++의 `map` 등에서 사용)
*   **수억 건의 데이터베이스 인덱싱**: 대용량 데이터를 디스크에 저장하고 관리해야 하는 경우, 디스크 I/O 횟수를 최소화할 수 있는 **B-트리** (또는 B+트리)가 필수적입니다.

---

## 4. 예상 면접 질문 (Potential Interview Questions)

*   **Q. 이진 탐색 트리의 최악의 경우 시간 복잡도가 O(n)이 되는 이유는 무엇이며, 이를 어떻게 해결할 수 있나요?**
    *   **A.** 데이터가 오름차순이나 내림차순으로 정렬된 상태로 삽입되면, 트리가 한쪽으로만 길어지는 편향 트리(Skewed Tree)가 됩니다. 이 경우, 트리의 높이가 노드의 개수(n)와 같아져서 특정 값을 탐색하려면 모든 노드를 순회해야 하므로 시간 복잡도가 O(n)이 됩니다. 이 문제는 **AVL 트리**나 **레드-블랙 트리**와 같은 **자가 균형 이진 탐색 트리**를 사용하여 해결할 수 있습니다. 이 트리들은 삽입/삭제 시 자동으로 트리의 균형을 맞춰 높이를 O(log n)으로 유지해줍니다.

*   **Q. AVL 트리와 레드-블랙 트리를 비교 설명해주세요.**
    *   **A.** 둘 다 자가 균형 이진 탐색 트리지만, 균형을 유지하는 전략에서 차이가 있습니다. AVL 트리는 모든 노드의 서브트리 높이 차이를 1 이하로 매우 엄격하게 유지하여 탐색 성능을 최적화합니다. 반면, 레드-블랙 트리는 색상 규칙을 통해 상대적으로 느슨하게 균형을 유지합니다. 이 때문에 레드-블랙 트리는 삽입/삭제 시 균형을 맞추기 위한 회전 연산이 AVL 트리보다 적게 발생하여, 삽입과 삭제가 빈번한 애플리케이션에 더 유리합니다.

*   **Q. 데이터베이스 인덱스에 B-트리를 사용하는 주된 이유는 무엇인가요?**
    *   **A.** 주된 이유는 **디스크 I/O 횟수를 최소화**하기 위함입니다. 데이터베이스의 데이터는 주로 디스크에 저장되는데, 디스크 접근은 메모리 접근보다 훨씬 느립니다. B-트리는 하나의 노드에 많은 수의 자식 노드를 가질 수 있어 트리의 전체 높이를 매우 낮게 유지할 수 있습니다. 트리의 높이가 곧 디스크 접근 횟수와 직결되므로, B-트리를 사용하면 대용량 데이터에서도 몇 번의 디스크 접근만으로 원하는 데이터를 찾을 수 있어 효율적입니다.

---

## 5. 더 읽어보기 (Further Reading)

*   [Introduction to Trees (GeeksforGeeks)](https://www.geeksforgeeks.org/introduction-to-tree-data-structure/)
*   [Red-Black Tree vs. AVL Tree (Baeldung)](https://www.baeldung.com/cs/avl-vs-red-black-trees)
*   [B-Tree | Set 1 (Introduction) (GeeksforGeeks)](https://www.geeksforgeeks.org/b-tree-set-1-introduction-2/)