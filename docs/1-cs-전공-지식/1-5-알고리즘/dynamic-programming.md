---
title: 동적 계획법 (배낭 문제, LIS)
date: '2025-07-02'
tags: [알고리즘, CS, DP, 동적계획법]
difficulty: hard
---

# 동적 계획법 (배낭 문제, LIS)

## 1. 핵심 개념 (Core Concept)

\*\*동적 계획법(Dynamic Programming, DP)\*\*은 복잡한 문제를 여러 개의 작은 \*\*하위 문제(Subproblem)\*\*로 나누어 푼 다음, 그 해를 \*\*저장(Memoization)\*\*하고 재활용하여 전체 문제의 답을 구하는 알고리즘 설계 기법입니다. 이는 계산된 값을 다시 계산하는 비효율을 줄여 알고리즘의 실행 속도를 비약적으로 향상시킬 수 있습니다. DP는 **최적화 문제**나 **경우의 수 계산**에 널리 사용됩니다.

______________________________________________________________________

## 2. 상세 설명 (Detailed Explanation)

### 2.1 동적 계획법의 조건

동적 계획법을 적용하기 위해서는 문제가 다음 두 가지 조건을 만족해야 합니다.

1. **중복되는 부분 문제 (Overlapping Subproblems)**: 큰 문제를 작은 문제로 나누었을 때, 동일한 작은 문제가 반복적으로 나타나야 합니다. 예를 들어 피보나치 수열에서 `fibo(5)`를 구하기 위해 `fibo(4)`와 `fibo(3)`을 계산해야 하고, `fibo(4)`를 계  하기 위해서는 또다시 `fibo(3)`과 `fibo(2)`를 계산해야 하는 것처럼 동일한 계산이 반복되는 구조를 가져야 합니다.
1. **최적 부분 구조 (Optimal Substructure)**: 문제의 최적 해결책이 부분 문제들의 최적 해결책으로 구성될 수 있어야 합니다. 즉, 작은 문제들의 최적 해를 조합하여 전체 문제의 최적 해를 구할 수 있어야 합니다.

### 2.2 동적 계획법 접근법

동적 계획법에는 대표적으로 두 가지 접근 방식이 있습니다.

- **하향식 접근법 (Top-down) - 메모이제이션 (Memoization)**:
  - 큰 문제에서 시작하여 작은 부분 문제로 나누어 가며 **재귀적**으로 문제를 해결합니다.
  - 이 과정에서 한 번 계산된 부분 문제의 해는 배열이나 해시 테이블에 \*\*저장(메모)\*\*해두었다가, 다시 같은 문제가 나타나면 저장된 값을 그대로 가져와 중복 계산을 피합니다.
- **상향식 접근법 (Bottom-up) - 타뷸레이션 (Tabulation)**:
  - 가장 작은 부분 문제부터 시작하여 차례대로 해를 구한 뒤, 이를 이용하여 점차 큰 문제의 해를 구해나가는 방식입니다.
  - 주로 **반복문**을 사용하여 구현하며, 계산된 결과는 DP 테이블(배열)에 순차적으로 저장됩니다.

일반적으로 상향식(Bottom-up) 방식이 재귀 호출 오버헤드가 없어 더 효율적입니다.

______________________________________________________________________

## 3. 예시 (Example)

### 3.1 0/1 배낭 문제 (0/1 Knapsack Problem)

무게 제한이 `W`인 배낭에 `n`개의 물건을 담을 때, 가치의 총합이 최대가 되도록 물건을 선택하는 문제입니다. 각 물건은 통째로 담거나 담지 않거나, 두 가지 선택만 가능합니다.

- **DP 정의**: `dp[i][w]` = `i`번째 물건까지 고려하고, 배낭의 무게 한도가 `w`일 때의 최대 가치.
- **점화식**:
  - `i`번째 물건을 담지 않는 경우: `dp[i-1][w]`
  - `i`번째 물건을 담는 경우: `dp[i-1][w - weight[i]] + value[i]`
  - `dp[i][w] = max(위 두 경우)`
- **구현**: 2차원 배열을 사용하여 Bottom-up 방식으로 테이블을 채워나갑니다.

```python
def knapsack_01(weights, values, W):
    n = len(weights)
    # dp[i][w]: i번째 물건까지 고려, 무게 한도 w일 때의 최대 가치
    dp = [[0 for _ in range(W + 1)] for _ in range(n + 1)]

    for i in range(1, n + 1):
        for w in range(1, W + 1):
            # i번째 물건의 무게와 가치 (인덱스 맞추기 위해 i-1)
            weight, value = weights[i-1], values[i-1]

            # 현재 물건을 배낭에 담을 수 없는 경우
            if weight > w:
                dp[i][w] = dp[i-1][w]
            # 현재 물건을 담는 경우와 담지 않는 경우 중 더 가치가 큰 쪽을 선택
            else:
                dp[i][w] = max(dp[i-1][w], dp[i-1][w - weight] + value)

    return dp[n][W]

# 예시 실행
weights = [2, 3, 4, 5]
values = [3, 4, 5, 6]
W = 5
print(f"최대 가치: {knapsack_01(weights, values, W)}") # 출력: 7 (3kg, 4kg 물건)
```

### 3.2 최장 증가 부분 수열 (Longest Increasing Subsequence, LIS)

주어진 수열에서 일부 원소를 제거하여 만들 수 있는, 오름차순으로 정렬된 가장 긴 부분 수열을 찾는 문제입니다.

- **DP 정의**: `dp[i]` = `i`번째 원소를 마지막으로 하는 가장 긴 증가 부분 수열의 길이.
- **점화식**: `i`번째 원소 이전의 모든 원소 `j` (j \< i)에 대해, `array[j] < array[i]`를 만족하는 경우 `dp[i] = max(dp[i], dp[j] + 1)`
- **구현**: 1차원 배열을 사용하여 Bottom-up 방식으로 해결합니다.

```python
def lis(arr):
    n = len(arr)
    if n == 0:
        return 0

    # dp[i]: i번째 원소를 마지막으로 하는 LIS의 길이
    dp = [1] * n

    for i in range(1, n):
        for j in range(i):
            if arr[j] < arr[i]:
                dp[i] = max(dp[i], dp[j] + 1)

    return max(dp)

# 예시 실행
arr = [10, 20, 10, 30, 20, 50]
print(f"LIS 길이: {lis(arr)}") # 출력: 4 (10, 20, 30, 50)
```

______________________________________________________________________

## 4. 예상 면접 질문 (Potential Interview Questions)

- **Q. 동적 계획법과 분할 정복의 공통점과 차이점은 무엇인가요?**

  - **A.** 공통점은 두 기법 모두 큰 문제를 작은 하위 문제로 나누어 해결한다는 점입니다. 가장 큰 차이점은 **하위 문제의 중복 여부**입니다. 분할 정복은 하위 문제들이 서로 **독립적**이어서 중복되지 않는 반면, 동적 계획법은 하위 문제들이 서로 **중복**되는 경우가 많습니다. 따라서 동적 계획법은 한 번 계산한 하위 문제의 결과를 \*\*메모이제이션(Memoization)\*\*이나 \*\*타뷸레이션(Tabulation)\*\*을 통해 저장해두고 재사용하여 중복 계산을 피합니다.

- **Q. 동적 계획법의 Top-down(메모이제이션) 방식과 Bottom-up(타뷸레이션) 방식의 장단점을 설명해주세요.**

  - **A.** **Top-down** 방식은 재귀를 사용하므로 문제의 점화식을 코드로 직관적으로 옮기기 쉽다는 장점이 있지만, 재귀 호출로 인한 시스템 스택 오버헤드가 발생할 수 있습니다. **Bottom-up** 방식은 반복문을 사용하므로 일반적으로 더 빠르고 메모리 사용도 효율적이지만, 문제 해결의 순서를 작은 문제부터 논리적으로 쌓아 올려야 하므로 코드의 흐름이 덜 직관적일 수 있습니다.

- **Q. 어떤 문제에 동적 계획법을 적용할 수 있을까요?**

  - **A.** 문제가 \*\*중복되는 부분 문제(Overlapping Subproblems)\*\*와 \*\*최적 부분 구조(Optimal Substructure)\*\*라는 두 가지 속성을 만족할 때 동적 계획법을 적용할 수 있습니다. 즉, 작은 문제들의 최적 해답을 통해 더 큰 문제의 최적 해답을 구할 수 있고, 그 과정에서 동일한 작은 문제들이 반복적으로 나타나는 경우에 효과적입니다. 피보나치 수열, 최단 경로 문제, 배낭 문제 등이 대표적인 예입니다.

______________________________________________________________________

## 5. 더 읽어보기 (Further Reading)

- [Dynamic Programming (GeeksforGeeks)](https://www.geeksforgeeks.org/dynamic-programming/)
- [동적 계획법 (나무위키)](https://namu.wiki/w/%EB%8F%99%EC%A0%81%20%EA%B3%84%ED%9A%8D%EB%B2%95)
- [0/1 Knapsack Problem (GeeksforGeeks)](https://www.geeksforgeeks.org/0-1-knapsack-problem-dp-10/)
