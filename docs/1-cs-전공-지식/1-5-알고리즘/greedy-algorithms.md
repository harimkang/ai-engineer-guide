---
title: 그리디 (활동 선택, 허프만 코딩)
date: '2025-07-02'
tags: [알고리즘, CS, 그리디]
difficulty: medium
---

# 그리디 (활동 선택, 허프만 코딩)

## 1. 핵심 개념 (Core Concept)

\*\*그리디 알고리즘(Greedy Algorithm, 탐욕법)\*\*은 문제를 해결하는 과정에서 **매 순간, 즉 각 단계에서 가장 최적이라고 생각되는 선택**을 하는 방식으로 최종적인 해답에 도달하려는 알고리즘 설계 기법입니다. '눈앞의 이익'을 우선적으로 추구하는 이 방식은 항상 최적의 해를 보장하지는 않지만, 특정 문제 유형에서는 동적 계획법보다 훨씬 빠르고 효율적으로 최적해를 찾아낼 수 있습니다.

______________________________________________________________________

## 2. 상세 설명 (Detailed Explanation)

### 2.1 그리디 알고리즘의 성립 조건

모든 문제에 그리디 알고리즘을 적용할 수 있는 것은 아닙니다. 그리디 알고리즘이 최적의 해를 보장하기 위해서는 다음 두 가지 조건을 반드시 만족해야 합니다.

1. **탐욕적 선택 속성 (Greedy Choice Property)**
   - 각 단계에서 하는 국소적으로 최적인 선택(Local Optimum)이 전역적으로도 최적인 해(Global Optimum)로 이어져야 합니다. 즉, 한 번의 선택이 이후의 다른 선택에 영향을 미치지 않아야 하며, 현재의 선택이 최적해를 구하는 데 안전해야 합니다.
1. **최적 부분 구조 (Optimal Substructure)**
   - 문제 전체의 최적해가 부분 문제들의 최적해로 구성될 수 있는 구조를 의미합니다. 즉, 한 단계에서 최적의 선택을 하고 남은 문제 또한 그 자체로 최적 부분 구조를 가져야 합니다. (이 조건은 동적 계획법과 공통적입니다.)

### 2.2 그리디 vs 동적 계획법

| 구분          | 그리디 알고리즘 (Greedy)                   | 동적 계획법 (Dynamic Programming)               |
| :------------ | :----------------------------------------- | :---------------------------------------------- |
| **선택 방식** | 매 순간 최적의 선택을 함 (되돌아보지 않음) | 모든 가능성을 고려 후 최적의 해를 찾음          |
| **하위 문제** | 한 번의 선택으로 하나의 하위 문제만 생성   | 여러 하위 문제가 발생할 수 있음 (중복 발생)     |
| **메모리**    | 추가 메모리 거의 불필요                    | 메모이제이션/타뷸레이션을 위한 추가 메모리 필요 |
| **속도**      | 일반적으로 더 빠름                         | 일반적으로 더 느림                              |
| **보장성**    | 최적해를 보장하지 않을 수 있음             | 항상 최적해를 보장함                            |

______________________________________________________________________

## 3. 예시 (Example)

### 3.1 활동 선택 문제 (Activity Selection Problem)

한정된 자원(예: 강의실)을 가지고 서로 겹치지 않게 최대한 많은 활동을 배정해야 하는 문제입니다.

- **그리디 전략**: **종료 시간이 가장 빠른 활동**을 먼저 선택합니다.
- **과정**:
  1. 모든 활동을 종료 시간 기준으로 오름차순 정렬합니다.
  1. 정렬된 목록의 첫 번째 활동을 선택합니다.
  1. 선택된 활동의 종료 시간 이후에 시작하는 활동 중에서, 종료 시간이 가장 빠른 다음 활동을 선택합니다.
  1. 더 이상 선택할 수 있는 활동이 없을 때까지 이 과정을 반복합니다.
- **정당성**: 가장 빨리 끝나는 활동을 선택하면, 남은 시간에 더 많은 활동을 할 수 있는 가능성이 극대화되므로 탐욕적 선택 속성을 만족합니다.

```python
def activity_selection(activities):
    # 활동을 종료 시간 기준으로 정렬
    activities.sort(key=lambda x: x[1])

    count = 0
    last_finish_time = -1
    selected_activities = []

    for start, finish in activities:
        if start >= last_finish_time:
            count += 1
            last_finish_time = finish
            selected_activities.append((start, finish))

    return count, selected_activities

# (시작 시간, 종료 시간)
activities = [(1, 4), (3, 5), (0, 6), (5, 7), (3, 8), (5, 9), (6, 10), (8, 11)]
count, result = activity_selection(activities)
print(f"선택된 최대 활동 수: {count}") # 4
print(f"선택된 활동: {result}") # [(1, 4), (5, 7), (8, 11)]
```

### 3.2 허프만 코딩 (Huffman Coding)

데이터 압축을 위해 사용되는 알고리즘으로, 빈도수에 따라 문자에 다른 길이의 코드를 부여합니다.

- **그리디 전략**: **등장 빈도가 낮은 문자**에 긴 코드를, **빈도가 높은 문자**에 짧은 코드를 할당하여 전체 데이터 길이를 최소화합니다.
- **과정**:
  1. 각 문자의 빈도수를 계산하여, 각 문자를 리프 노드로 하는 트리를 만듭니다.
  1. 빈도수가 가장 낮은 두 개의 노드를 선택하여 하나의 부모 노드로 묶습니다. 이 부모 노드의 빈도수는 두 자식 노드의 빈도수 합입니다.
  1. 모든 노드가 하나의 트리로 묶일 때까지 2번 과정을 반복합니다. (우선순위 큐를 사용하면 효율적)
  1. 생성된 이진 트리에서 왼쪽 가지는 `0`, 오른쪽 가지는 `1`을 부여하여 각 문자의 코드를 생성합니다.

______________________________________________________________________

## 4. 예상    접 질문 (Potential Interview Questions)

- **Q. 그리디 알고리즘이 항상 최적의 해를 보장하지 않는 이유는 무엇인가요? 예시를 들어 설명해주세요.**

  - **A.** 그리디 알고리즘은 매 순간의 선택이 미래에 어떤 영향을 미칠지 고려하지 않고, 현재 상황에서만 최적인 선택을 하기 때문입니다. 예를 들어, 거스름돈 문제에서 동전 단위가 \[1, 5, 8\]원이고 10원을 거슬러줘야 할 때, 그리디 방식은 가장 큰 단위인 8원을 먼저 선택하고 남은 2원을 1원 두 개로 거슬러주어 총 3개의 동전을 사용합니다. 하지만 최적해는 5원짜리 두 개를 사용하여 총 2개의 동전만 사용하는 것입니다. 이처럼 '지금의 최선'이 '전체의 최선'이 아닐 수 있기 때문에 최적해를 보장하지 못하는 경우가 있습니다.

- **Q. 그리디 알고리즘을 적용할 수 있는 문제의 두 가지 조건은 무엇인가요?**

  - **A.** \*\*탐욕적 선택 속성(Greedy Choice Property)\*\*과 \*\*최적 부분 구조(Optimal Substructure)\*\*입니다. 탐욕적 선택 속성은 각 단계에서의 최선의 선택이 전체 문제의 최적해를 구하는 데 영향을 주지 않고 항상 안전해야 한다는 의미입니다. 최적 부분 구조는 문제의 최적해가 그 부분 문제들의 최적해로 구성될 수 있다는 의미입니다.

- **Q. 활동 선택 문제에서 '가장 빨리 끝나는 활동'을 선택하는 그리디 전략이 최적인 이유를 설명해주세요.**

  - **A.** 가장 빨리 끝나는 활동을 선택하면, 다음 활동을 선택할 수 있는 **시간을 최대한 많이 확보**할 수 있기 때문입니다. 만약 종료 시간이 더 늦은 다른 활동을 선택한다면, 그 활동이 진행되는 동안 시작할 수 있었던 다른 잠재적인 활동들을 포기해야 할 수도 있습니다. 따라서 현재 시점에서 가장 빨리 자원을 반납(활동 종료)하는 선택이, 남은 문제(시간)에 대해서도 최적의 해를 구할 수 있는 기회를 최대로 보장해주므로 최적입니다.

______________________________________________________________________

## 5. 더 읽어보기 (Further Reading)

- [Greedy Algorithms (GeeksforGeeks)](https://www.geeksforgeeks.org/greedy-algorithms/)
- [Activity Selection Problem (Programiz)](https://www.programiz.com/dsa/activity-selection-problem)
- [Huffman Coding (Wikipedia)](https://en.wikipedia.org/wiki/Huffman_coding)
