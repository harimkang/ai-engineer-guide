---
title: 정렬 (퀵, 병합, 힙, TimSort)
date: '2025-07-02'
tags: [알고리즘, CS, 정렬, 퀵정렬, 병합정렬, 힙정렬, 팀소트]
difficulty: medium
---

# 정렬 (퀵, 병합, 힙, TimSort)

## 1. 핵심 개념 (Core Concept)

\*\*정렬(Sorting)\*\*은 데이터를 특정 기준에 따라 순서대로 나열하는 알고리즘입니다. **퀵 정렬, 병합 정렬, 힙 정렬**은 평균 O(n log n)의 시간 복잡도를 가지는 대표적인 비교 기반 정렬 알고리즘입니다. \*\*팀소트(TimSort)\*\*는 병합 정렬과 삽입 정렬을 결합한 하이브리드 정렬 알고리즘으로, 실제 데이터 환경에서 매우 효율적으로 동작하여 파이썬, 자바 등 여러 언어의 기본 정렬 알고리즘으로 채택되었습니다.

______________________________________________________________________

## 2. 상세 설명 (Detailed Explanation)

### 2.1 비교 기반 정렬 알고리즘

| 구분                   | 퀵 정렬 (Quick Sort)  | 병합 정렬 (Merge Sort)         | 힙 정렬 (Heap Sort) | 팀소트 (TimSort)          |
| :--------------------- | :-------------------- | :----------------------------- | :------------------ | :------------------------ |
| **핵심 아이디어**      | 분할 정복 (피벗 기준) | 분    정복 (균등 분할 후 병합) | 힙(Heap) 자료구조   | **삽입 정렬 + 병합 정렬** |
| **시간 복잡도 (평균)** | **O(n log n)**        | O(n log n)                     | O(n log n)          | O(n log n)                |
| **시간 복잡도 (최악)** | **O(n²)**             | **O(n log n)**                 | O(n log n)          | **O(n log n)**            |
| **공간 복잡도**        | O(log n)              | **O(n)**                       | **O(1)**            | O(n) 또는 O(log n)        |
| **안정성 (Stability)** | 불안정 (Unstable)     | **안정 (Stable)**              | 불안정 (Unstable)   | **안정 (Stable)**         |

- **안정 정렬(Stable Sort)**: 같은 값을 가진 요소들의 상대적인 순서가 정렬 후에도 유지되는 정렬 방식.

### 2.2 알고리즘별 상세

#### 가. 퀵 정렬 (Quick Sort)

- **동작 원리**: '분할 정복' 전략을 사용. 배열 내의 한 요소를 \*\*피벗(pivot)\*\*으로 선택하여, 피벗보다 작은 요소들은 왼쪽으로, 큰 요소들은 오른쪽으로 분할합니다. 이 과정을 재귀적으로 반복하여 전체 배열을 정렬합니다.
- **장점**: 평균적으로 매우 빠른 속도를 자랑하며, 추가적인 메모리 공간을 거의 필요로 하지 않는 \*\*제자리 정렬(in-place sort)\*\*입니다.
- **단점**: 피벗 선택에 따라 성능이 크게 달라집니다. 이미 정렬된 배열에서 비효율적인 피벗을 선택하면 최악의 시간 복잡도인 O(n²)가 발생할 수 있습니다.

#### 나. 병합 정렬 (Merge Sort)

- **동작 원리**: '분할 정복'에 기반. 배열을 더 이상 나눌 수 없을 때까지 절반으로 나누고, 정렬된 부분 배열들을 다시 병합하면서 전체를 정렬합니다.
- **장점**: 데이터 분포에 영향을 받지 않는 \*\*안정적인 성능(항상 O(n log n))\*\*을 제공하며, **안정 정렬**입니다.
- **단점**: 정렬 과정에서 임시 배열이 필요하므로 **O(n)의 추가적인 메모리 공간**을 사용합니다.

#### 다. 힙 정렬 (Heap Sort)

- **동작 원리**: '힙(heap)'이라는 자료구조를 이용하여 정렬을 수행합니다. 먼저 배열을 최대 힙(max heap)으로 구성한 뒤, 루트 노드(최댓값)를 배열의 마지막 요소와 바꾸고 힙 크기를 줄이는 과정을 반복합니다.
- **장점**: 항상 O(n log n)의 시간 복잡도를 보장하며, **O(1)의 추가 공간**만 사용하는 제자리 정렬입니다.
- **단점**: 데이터의 상대적인 순서가 보장되지 않는 불안정 정렬이며, 실제 환경에서는 캐시 효율성 문제로 퀵 정렬보다 느린 경우가 많습니다.

#### 라. 팀소트 (TimSort)

- **동작 원리**: 삽입 정렬과 병합 정렬을 결합한 **하이브리드 적응형(adaptive) 정렬** 알고리즘입니다. 실제 데이터는 대부분 부분적으로 정렬되어 있다는 점에 착안하여 설계되었습니다.
  1. 데이터를 '런(run)'이라는 작은 단위(보통 32 또는 64개)로 나눕니다.
  1. 각 런은 **삽입 정렬**로 효율적으로 정렬합니다. (작은 데이터셋에서는 삽입 정렬이 빠름)
  1. 정렬된 런들을 **병합 정렬**을 이용해 효율적으로 병합합니다.
- **장점**: 이미 데이터가 정렬되어 있는 최선의 경우 \*\*O(n)\*\*의 매우 빠른 속도를 보입니다. 안정 정렬이며, 실제 데이터에서 매우 효율적으로 동작하도록 최적화되어 있습니다.
- **사용처**: 파이썬(`sorted()`, `list.sort()`), 자바(객체 배열) 등 여러 프로그래밍 언어에서 **기본 정렬 알고리즘**으로 채택되어 사용되고 있습니다.

______________________________________________________________________

## 3. 예시 (Example)

### 퀵 정렬 (Quick Sort) 코드 예시 (Python)

```python
def quick_sort(arr):
    if len(arr) <= 1:
        return arr

    pivot = arr[len(arr) // 2]
    lesser_arr, equal_arr, greater_arr = [], [], []

    for num in arr:
        if num < pivot:
            lesser_arr.append(num)
        elif num > pivot:
            greater_arr.append(num)
        else:
            equal_arr.append(num)

    return quick_sort(lesser_arr) + equal_arr + quick_sort(greater_arr)

# 예시 실행
my_array = [38, 27, 43, 3, 9, 82, 10]
sorted_array = quick_sort(my_array)
print(f"정렬된 배열: {sorted_array}")
```

______________________________________________________________________

## 4. 예상 면접 질문 (Potential Interview Questions)

- **Q. 퀵 정렬과 병합 정렬을 비교 설명해주세요.**

  - **A.** 둘 다 분할 정복을 사용하는 O(n log n)의 효율적인 정렬 알고리즘입니다. 하지만 **퀵 정렬**은 피벗을 기준으로 분할한 뒤 정렬하므로 추가 공간이 거의 필요 없는(O(log n)) 제자리 정렬이지만, 최악의 경우 O(n²)의 성능을 보이고 불안정 정렬입니다. 반면, **병합 정렬**은 항상 O(n log n)의 안정적인 성능을 보장하고 안정 정렬이지만, 정렬을 위한 추가 배열이 필요하여 O(n)의 공간 복잡도를 가집니다.

- **Q. 파이썬의 기본 정렬 함수가 사용하는 팀소트(TimSort)는 왜 효율적인가요?**

  - **A.** 팀소트는 실제 세계의 데이터가 완전히 무작위가 아니라 **부분적으로 정렬된 경우가 많다**는 점을 활용하기 때문입니다. 작은 데이터 묶음(런)에 대해서는 오버헤드가 적고 빠른 **삽입 정렬**을 사용하고, 이렇게 정렬된 런들을 합칠 때는 안정적이고 효율적인 **병합 정렬**을 사용합니다. 이처럼 두 알고리즘의 장점을 결합한 하이브리드 방식이기 때문에, 다양한 데이터 분포에 대해 평균적으로 매우 높은 성능을 보입니다.

- **Q. 안정 정렬(Stable Sort)이란 무엇이며, 왜 중요한가요?**

  - **A.** 안정 정렬은 같은 값을 가진 원소들의 상대적인 순서가 정렬 후에도 그대로 유지되는 정렬 방식을 말합니다. 예를 들어, (점수, 이름)으로 구성된 데이터를 점수 순으로 정렬할 때, 점수가 같은 학생들의 이름 순서가 원래 순서대로 유지된다면 안정 정렬입니다. 이는 사용자가 의도한 2차, 3차 정렬 기준을 유지하는 데 중요하기 때문에, 복합적인 데이터를 다룰 때 매우 유용한 특성입니다.

______________________________________________________________________

## 5. 더 읽어보기 (Further Reading)

- [Sorting algorithm (Wikipedia)](https://en.wikipedia.org/wiki/Sorting_algorithm)
- [A Guide to Sorting Algorithms in Python (Real Python)](https://realpython.com/sorting-algorithms-python/)
- [Timsort — the fastest sorting algorithm you’ve never heard of](https://hackernoon.com/timsort-the-fastest-sorting-algorithm-youve-never-heard-of-36b28417f399)
