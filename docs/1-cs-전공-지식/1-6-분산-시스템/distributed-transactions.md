---
title: 분산 트랜잭션 (2PC, 3PC, Saga)
date: '2025-07-02'
tags: [분산시스템, CS, 트랜잭션, 2PC, Saga]
difficulty: hard
---

# 분산 트랜잭션 (2PC, 3PC, Saga)

## 1. 핵심 개념 (Core Concept)

**분산 트랜잭션**은 여러 개의 독립된 시스템이나 데이터베이스에 걸쳐있는 작업을 하나의 원자적인 단위로 묶어 처리하는 기술입니다. 모든 작업이 전부 성공하거나(Commit) 하나라도 실패할 경우 모든 작업이 취소(Rollback)되는 것을 목표로 합니다. 이를 구현하기 위한 대표적인 프로토콜로 \*\*2PC(Two-Phase Commit)\*\*와 **3PC**가 있으며, 마이크로서비스 아키텍처에서는 최종 일관성을 기반으로 하는 **Saga 패턴**이 널리 사용됩니다.

______________________________________________________________________

## 2. 상세 설명 (Detailed Explanation)

### 2.1 2PC (Two-Phase Commit)

2PC는 분산 트랜잭션의 원자성을 보장하기 위한 가장 대표적인 프로토콜로, \*\*코디네이터(Coordinator)\*\*와 다수의 \*\*참여자(Participants)\*\*로 구성됩니다.

- **1단계: 준비 단계 (Prepare Phase)**

  1. 코디네이터가 모든 참여자에게 트랜잭션을 커밋할 준비가 되었는지 묻는 'Prepare' 메시지를 보냅니다.
  1. 각 참여자는 자신의 로컬 트랜잭션을 실행하고, 성공적으로 완료할 수 있으면 로그를 기록한 뒤 'Prepared' 메시지를, 실패하면 'Abort' 메시지를 코디네이터에게 응답합니다.

- **2단계: 커밋 단계 (Commit Phase)**

  1. **모든** 참여자로부터 'Prepared' 메시지를 받으면, 코디네이터는 모든 참여자에게 'Commit' 메시지를 보냅니다.
  1. 한 명이라도 'Abort' 메시지를 보내거나 응답이 없으면, 모든 참여자에게 'Rollback' 메시지를 보냅니다.
  1. 참여자는 코디네이터의 메시지에 따라 자신의 로컬 트랜잭션을 최종적으로 커밋하거나 롤백합니다.

- **단점**:

  - **블로킹(Blocking) 문제**: 코디네이터나 참여자 중 하나라도 장애가 발생하면, 다른 참여자들은 응답을 기다리며 무한정 대기 상태에 빠질 수 있습니다.
  - **단일 장애 지점(SPOF)**: 코디네이터에 장애가 발생하면 전체 트랜잭션이 중단되거나 복구가 어려워집니다.

### 2.2 3PC (Three-Phase Commit)

3PC는 2PC의 블로킹 문제를 해결하기 위해 'Pre-Commit' 단계를 추가한 프로토콜입니다.

- **추가된 단계: 사전 커밋 (Pre-Commit Phase)**
  - 코디네이터는 모든    여자로부터 'Prepared' 응답을 받으면 'Pre-Commit' 메시지를 보냅니다. 이 단계는 모든 참여자가 커밋할 준비가 되었음을 서로 확인하는 과정입니다.
- **장점**: 코디네이터 장애 시 참여자들이 타임아웃을 통해 독립적으로 커밋 또는 롤백을 결정할 수 있어 블로킹 문제를 완화합니다.
- **단점**: 프로토콜이 더 복잡하고, 네트워크 분할 문제에 취약하며 통신 오버헤드가 증가합니다. 이러한 단점 때문에 실제로는 2PC보다 널리 사용되지 않습니다.

### 2.3 Saga 패턴

Saga 패턴은 \*\*장기 실행 트랜잭션(Long-running Transaction)\*\*을 처리하기 위한 분산 트랜잭션 패턴으로, 마이크로서비스 아키텍처에서 주로 사용됩니다. 하나의 큰 트랜잭션을 여러 개의 작은 **로컬 트랜잭션**의 시퀀스로 나눕니다.

- **동작 방식**:

  - 각 로컬 트랜잭션이 성공하면 다음 로컬 트랜잭션을 호출합니다.
  - 만약 중간에 로컬 트랜잭션이 실패하면, 이전에 성공했던 트랜잭션들을 되돌리는 \*\*보상 트랜잭션(Compensating Transaction)\*\*을 역순으로 실행하여 데이터의 일관성을 맞춥니다.

- **구현 방식**:

  - **코레오그래피 (Choreography)**: 중앙 조정자 없이 각   비스가 이벤트를 발행(Publish)하고 구독(Subscribe)하여 다음 트랜잭션을 연쇄적으로 트리거하는 방식. (느슨한 결합)
  - **오케스트레이션 (Orchestration)**: 중앙의 오케스트레이터가 전체 Saga의 흐름을 관리하고 각 서비스의 트랜잭션 실행을 조율하는 방식. (명시적인 흐름 제어)

- **특징**:

  - ACID의 강한 일관성 대신 \*\*최종 일관성(Eventual Consistency)\*\*을 보장합니다.
  - 특정 서비스가 오랜 시간 작업을 수행하더라도 다른 서비스를 블로킹하지 않습니다.

### 2.4 비교 요약

| 구분               | 2PC (Two-Phase Commit)                                  | Saga 패턴                                            |
| :----------------- | :------------------------------------------------------ | :--------------------------------------------------- |
| **일관성 모델**    | **강한 일관성 (Strong Consistency)**                    | **최종 일관성 (Eventual Consistency)**               |
| **동작 방식**      | 동기 (Synchronous), 블로킹                              | 비동기 (Asynchronous), 논블로킹                      |
| **결합도**         | 높음 (High Coupling)                                    | 낮음 (Loose Coupling)                                |
| **장애 처리**      | 블로킹 발생 가능성 높음                                 | 보상 트랜잭션을 통한 복구                            |
| **복잡성**         | 비교적 단순                                             | 매우 복잡 (보상 트랜잭션 구현 필요)                  |
| **주요 사용 사례** | 모놀리식 아키텍처, 데이터의 강한 일관성이 필수적인 경우 | **마이크로서비스 아키텍처(MSA)**, 장기 실행 트랜잭션 |

______________________________________________________________________

## 3. 예시 (Example)

### 온라인 쇼핑 주문 시나리오

사용자가 '주문하기' 버튼을 누르면 **주문 서비스, 결제 서비스, 재고 서비스**가 함께 동작해야 합니다.

- **2PC 방식**:

  1. 트랜잭션 매니저가 주문, 결제, 재고 서비스에 "준비하라"고 요청.
  1. 세 서비스 모두 "준비 완료" 응답.
  1. 트랜잭션 매니저가 세 서비스에 "커밋하라"고 명령.
  1. 만약 재고 서비스가 응답이 없다면, 주문과 결제 서비스는 무한정 대기(블로킹) 상태에 빠짐.

- **Saga 패턴 (오케스트레이션 방식)**:

  1. **주문 생성**: 주문 오케스트레이터가 '주문 서비스'에 주문 생성을 요청. (성공)
  1. **결제 처리**: 오케스트레이터가 '결제 서비스'에 결제 처리를 요청. (성공)
  1. **재고 차감**: 오케스트레이터가 '재고 서비스'에 재고 차감을 요청. (**실패**)
  1. **보상 트랜잭션 실행**:
     - 오케스트레이터가 '결제 서비스'에 **결제 취소**를 요청.
     - 오케스트레이터가 '주문 서비스'에 **주문 취소**를 요청.
  1. 최종적으로 모든 작업이 취소되어 데이터 일관성이 맞춰짐.

______________________________________________________________________

## 4. 예상 면접 질문 (Potential Interview Questions)

- **Q. 2PC의 가장 큰 문제점은 무엇이며, Saga 패턴은 이를 어떻게 해결하나요?**

  - **A.** 2PC의 가장 큰 문제점은 코디네이터나 참여자 중 하나라도 장애가 발생하면 다른 모든 참여자들이 작업을 완료하지 못하고 무한정 대기하는 **블로킹(Blocking)** 문제와, 코디네이터가 다운되면 전체 시스템이 멈추는 **단일 장애 지점(SPOF)** 문제입니다. Saga 패턴은 각 서비스를 독립적인 로컬 트랜잭션으로 분리하고 비동기적으로 호출함으로써 이 문제를 해결합니다. 특정 서비스가 실패하더라도 다른 서비스가 블로킹되지 않으며, 실패한 트랜잭션에 대한 보상 트랜잭션을 실행하여 최종적인 데이터 일관성을 맞춥니다.

- **Q. Saga 패턴을 사용할 때의 단점, 즉 트레이드오프는 무엇인가요?**

  - **A.** 가장 큰 단점은 \*\*최종 일관성(Eventual Consistency)\*\*을 가진다는 점입니다. 2PC처럼 강한 일관성을 보장하지 않기 때문에, 트랜잭션이 진행 중인 중간 상태에서는 데이터가 일시적으로 불일치할 수 있습니다. 또한, 모든 로컬 트랜잭션에 대한 **보상 트랜잭션을 직접 개발하고 관리**해야 하므로 설계와 구현의 복잡성이 매우 높아진다는 단점이 있습니다.

- **Q. 코레오그래피 Saga와 오케스트레이션 Saga는 어떤 차이가 있나요?**

  - **A.** **코레오그래피** 방식은 중앙 조정자 없이 각 서비스가 **이벤트**를 통해 서로를 연쇄적으로 호출하는 방식입니다. 서비스 간의 결합도가 매우 낮다는 장점이 있지만, 전체 트랜잭션의 흐름을 파악하고 디버깅하기가 어렵습니다. 반면, **오케스트레이션** 방식은 **중앙의 오케스트레이터**가 명시적으로 각 서비스의 트랜잭션을 호출하고 전체 흐름을 관리합니다. 흐름이 중앙 집중화되어 이해하고 관리하기는 쉽지만, 오케스트레이터에 대한 의존성이 높아진다는 단점이 있습니다.

______________________________________________________________________

## 5. 더 읽어보기 (Further Reading)

- [Two-phase commit protocol (Wikipedia)](https://en.wikipedia.org/wiki/Two-phase_commit_protocol)
- [Pattern: Saga (Microservices.io)](https://microservices.io/patterns/data/saga.html)
- [Distributed Transactions: The Icebergs of Microservices (NServiceBus blog)](https://particular.net/blog/distributed-transactions-the-icebergs-of-microservices)
