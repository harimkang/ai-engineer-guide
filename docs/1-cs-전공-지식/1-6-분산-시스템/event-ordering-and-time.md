---
title: 이벤트 순서 & 시간 (논리적 시계)
date: '2025-07-02'
tags: [분산시스템, CS, 논리시계, Lamport, VectorClock]
difficulty: hard
---

# 이벤트 순서 & 시간 (논리적 시계)

## 1. 핵심 개념 (Core Concept)

분산 시스템에서는 여러 노드에서 동시에 이벤트가 발생하며, 각 노드의 물리적 시계는 오차가 있어 전역적으로 완벽한 시간 동기화가 불가능합니다. 이로 인해 이벤트의 발생 순서를 결정하는 것이 매우 어렵습니다. \*\*논리적 시계(Logical Clock)\*\*는 실제 시간이 아닌, 이벤트 간의 \*\*인과 관계(Causality)\*\*를 기반으로 순서를 정의하는 기법입니다. 대표적인 논리적 시계로는 \*\*램포트 시계(Lamport Clock)\*\*와 \*\*벡터 시계(Vector Clock)\*\*가 있습니다.

______________________________________________________________________

## 2. 상세 설명 (Detailed Explanation)

### 2.1 물리적 시간의 한계와 논리적 시계의 등장

분산 시스템의 각 노드는 자신만의 물리적 시계를 가지고 있지만, 시간 오차(Clock Skew)와 네트워크 지연(Latency)으로 인해 모든 노드의 시간을 완벽하게 동기화하는 것은 불가능합니다. 물리적 시계의 타임스탬프는 이벤트의 실제 발생 순서와 일치하지 않을 수 있으며, 이는 데이터의 인과 관계를 왜곡시켜 심각한 문제를 유발할 수 있습니다.

이러한 한계를 극복하고 이벤트의 논리적인 순서를 정의하기 위해 **논리적 시계**라는 개념이 도입되었습니다. 논리적 시계는 실제 시간이 아닌, 이벤트 발생 순서에 기반하여 단조롭게 증가하는 카운터입니다.

### 2.2 램포트 시계 (Lamport Clock)

레슬리 램포트가 제안한 램포트 시계는 분산 시스템에서 이벤트의 \*\*인과 관계("happened-before" 관계)\*\*를 파악하기 위한 최초의 논리적 시계 알고리즘입니다.

- **규칙**:
  1. 각 프로세스는 내부 이벤트가 발생할 때마다 자신의 논리적 시계 값을 1 증가시킵니다.
  1. 프로세스가 메시지를 다른 프로세스에게 보낼 때, 자신의 논리적 시계 값을 메시지에 담아 보냅니다.
  1. 메시지를 받은 프로세스는 `max(자신의 시계 값, 메시지의 시계 값) + 1` 로 자신의 시계를 업데이트합니다.
- **의미**: 이벤트 A가 이벤트 B의 원인이 되는 인과 관계(A → B)가 있다면, 항상 램포트 시간 `C(A) < C(B)`가 성립합니다.
- **한계**: 역은 성립하지 않습니다. 즉, `C(A) < C(B)`라고 해서 반드시 A와 B 사이에 인과 관계가 있다고 말할 수 없습니다. 두 이벤트가 **동시에 발생했는지 여부를 구별할 수 없습니다.**

### 2.3 벡터 시계 (Vector Clock)

벡터 시계는 램포트 시계의 한계를 보완하여, 이벤트 간의 **인과 관계뿐만 아니라 동시성까지 파악**할 수 있도록 고안된 논리적 시계입니다.

- **구조**: 시스템의 모든 프로세스(N개)에 대한 논리적 시계 값을 **N차원 벡터 형태**로 유지합니다. `VC(P_i) = [c_1, c_2, ..., c_i, ..., c_n]`에서 `c_i`는 프로세스 `P_i` 자신의 논리적 시간, `c_j` (j≠i)는 `P_i`가 알고 있는 `P_j`의 논리적 시간입니다.
- **규칙**:
  1. 내부 이벤트 발생 시, 자신의 벡터 값(`c_i`)만 1 증가시킵니다.
  1. 메시지 전송 시, 자신의 벡터 시계 전체를 메시지에 담아 보냅니다.
  1. 메시지 수신 시, 자신의 벡터와 메시지의 벡터 각 요소를 비교하여 더 큰 값으로 자신의 벡터를 업데이트하고, 그 다음 자신의 벡터 값(`c_i`)을 1 증가시킵니다.
- **의미**: 두 이벤트 A, B의 벡터 시계 `VC(A)`와 `VC(B)`를 비교하여 인과 관계(선후 관계)와 동시 발생 여부를 정확하게 판단할 수 있습니다.
- **단점**: 모든 프로세스의 정보를 벡터에 담아 통신해야 하므로 램포트 시계에 비해 오버헤드가 큽니다.

### 2.4 비교 요약

| 구분               | 램포트 시계 (Lamport Clock)  | 벡터 시계 (Vector Clock) |
| :----------------- | :--------------------------- | :----------------------- |
| **타임스탬프**     | 단일 정수 값                 | **정수 벡터**            |
| **인과 관계 파악** | 가능 (A→B 이면 C(A) \< C(B)) | **정확하게 가능**        |
| **동시성 파악**    | **불가능**                   | **가능**                 |
| **오버헤드**       | 낮음                         | 높음                     |

______________________________________________________________________

## 3. 예시 (Example)

### 이벤트 순서 판별 시나리오

세 개의 프로세스 P1, P2, P3가 통신하는 상황을 가정해봅시다.

- **램포트 시계**:

  - P1에서 이벤트 A(시간=1) 발생 후 P2로 메시지 전송.
  - P3에서 이벤트 C(시간=1) 발생.
  - P2가 메시지를 받고 이벤트 B(시간=max(0,1)+1=2) 발생.
  - **결과**: C(A)=1, C(B)=2, C(C)=1. 램포트 시간만으로는 A와 C의 선후 관계나 동시성 여부를 알 수 없습니다.

- **벡터 시계**:

  - P1에서 이벤트 A 발생: `VC(A) = [1, 0, 0]`
  - P3에서 이벤트 C 발생: `VC(C) = [0, 0, 1]`
  - P1이 P2로 메시지 전송.
  - P2가 메시지를 받고 이벤트 B 발생: `VC(B) = [1, 1, 0]`
  - **결과**:
    - `VC(A)`와 `VC(C)`는 어느 한쪽이 다른 쪽의 모든 요소보다 크거나 같지 않으므로, **A와 C는 동시성(concurrent) 관계**입니다.
    - `VC(A)`의 모든 요소가 `VC(B)`의 요소보다 작거나 같으므로, \*\*A는 B의 원인(A → B)\*\*입니다.

______________________________________________________________________

## 4. 예상 면접 질문 (Potential Interview Questions)

- **Q. 분산 시스템에서 물리적 시간 대신 논리적 시계를 사용하는 이유는 무엇인가요?**

  - **A.** 분산 환경의 각 노드는 독립적인 물리적 시계를 가지며, 네트워크 지연 등으로 인해 이 시계들을 완벽하게 동기화하는 것은 불가능합니다. 이로 인해 물리적 시간만으로는 여러 노드에서 발생한 이벤트들의 정확한 선후 관계나 인과 관계를 파악하기 어렵습니다. 논리적 시계는 실제 시간이 아닌 이벤트 간의 논리적인 순서에 집중하여, 분산 시스템에서 발생하는 작업들의 순서를 일관되게 정의하고 데이터 무결성을 보장하기 위해 사용됩니다.

- **Q. 램포트 시계의 한계점은 무엇이며, 벡터 시계는 이를 어떻게 해결했나요?**

  - **A.** 램포트 시계의 가장 큰 한계는 **동시성을 구별할 수 없다**는 점입니다. `C(A) < C(B)`이면 A가 B의 원인이라고 말할 수 있지만, 그 역은 성립하지 않아 인과 관계를 완벽히 파악할 수 없습니다. 벡터 시계는 각 프로세스에 대한 시간 정보를 벡터 형태로 유지함으로써 이 문제를 해결했습니다. 벡터 시계를 비교하면 두 이벤트가 명확한 선후 관계(인과 관계)에 있는지, 아니면 서로 독립적으로 발생한 동시성 관계에 있는지를 정확하게 판단할 수 있습니다.

- **Q. 벡터 시계의 단점은 무엇이며, 어떤 상황에서 사용하기 부적합할 수 있나요?**

  - **A.** 벡터 시계의 가장 큰 단점은 **오버헤드**입니다. 시스템에 참여하는 프로세스의 수가 N개일 때, N차원의 벡터를 모든 메시지에 포함시켜야 하므로 프로세스 수가 많아질수록 네트워크 오버헤드가 크게 증가합니다. 따라서, 수천, 수만 개의 노드가 참여하는 대규모 분산 시스템에서는 벡터 시계의 오버헤드가 부담이 되어 사용하기 부적합할 수 있습니다.

______________________________________________________________________

## 5. 더 읽어보기 (Further Reading)

- [Lamport timestamps (Wikipedia)](https://en.wikipedia.org/wiki/Lamport_timestamps)
- [Vector clock (Wikipedia)](https://en.wikipedia.org/wiki/Vector_clock)
- [Time, Clocks, and the Ordering of Events in a Distributed System (Leslie Lamport, 1978)](https://lamport.azurewebsites.net/pubs/time-clocks.pdf)
