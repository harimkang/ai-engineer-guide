---
title: ReAct (Reason + Act)
date: 2025-10-29
tags:
  - Agentic-AI
  - Reasoning
  - Tool-Use
  - ReAct
difficulty: medium
---

# ReAct (Reason + Act)

## 1. 핵심 개념 (Core Concept)

ReAct는 LLM에게 **추론(Reason)** 과 **행동(Act)** 을 번갈아 수행하도록 하여, 외부 도구와의 상호작용을 통해 지식을 확장하고 주어진 과업을 해결해나가는 동적인 추론 패턴입니다. 이는 마치 사람이 문제를 풀 때, '생각'을 하고, 부족한 정보를 얻기 위해 책을 찾아보는 '행동'을 한 뒤, 얻은 정보를 바탕으로 다시 '생각'을 이어가는 과정과 같습니다. ReAct는 CoT의 순수 추론 능력을 넘어, 에이전트에게 **'손과 발(도구)'** 을 달아주는 핵심적인 패턴입니다.

![ReAct Loop Diagram](../../images/react-loop-diagram.png)

______________________________________________________________________

## 2. 상세 설명 (Detailed Explanation)

### 2.1 Thought → Action → Observation 루프

ReAct 패턴은 세 가지 요소를 반복하는 루프로 동작합니다.

1. **Thought (생각)**: 현재까지의 정보와 목표를 바탕으로, 상황을 분석하고 다음 행동 계획을 수립합니다. (예: "사용자가 CEO를 물어봤으니, 회사 이름을 먼저 알아내야겠다.")
1. **Action (행동)**: 생각 단계에서 수립한 계획을 실행합니다. 이는 보통 외부 도구를 호출하는 형태로 나타납니다. (예: `search("아이폰 제조사")`)
1. **Observation (관찰)**: 행동의 결과를 받아옵니다. 이는 API의 응답, 웹 페이지의 내용, 데이터베이스 조회 결과 등이 될 수 있습니다. (예: "검색 결과: Apple Inc.")

이 관찰 결과는 다시 다음 Thought 단계의 입력으로 사용되어, 목표를 달성할 때까지 루프가 반복됩니다.

### 2.2 ReAct의 장점과 단점

- **장점**:
  - **최신성 및 사실성**: 외부 도구(특히 검색)를 통해 LLM이 학습하지 않은 최신 정보나 사실을 반영할 수 있어 환각(Hallucination)을 크게 줄입니다.
  - **투명성 및 디버깅 용이성**: 에이전트의 모든 생각과 행동, 관찰 과정이 로그로 남기 때문에, 왜 그런 결정을 내렸는지 추적하고 실패 원인을 분석하기 쉽습니다.
  - **유연성**: 정해진 계획만 따르는 것이 아니라, 관찰 결과에 따라 동적으로 계획을 수정하며 예상치 못한 문제에 대응할 수 있습니다.
- **단점**:
  - **비용 및 지연**: 여러 번의 LLM 호출과 도구 호출이 필요하므로, 단일 프롬프트로 해결하는 것보다 비용이 많이 들고 응답 시간이 길어집니다.
  - **도구 의존성**: 도구의 성능과 안정성에 전체 시스템의 품질이 크게 좌우됩니다. 도구가 실패하면 전체 작업이 실패할 수 있습니다.

______________________________________________________________________

## 3. 예시 (Example)

**목표**: "마지막 슈퍼볼이 열린 도시의 현재 날씨는?"

1. **Thought**: 사용자의 질문에 답하려면 먼저 마지막 슈퍼볼이 어디서 열렸는지 알아야 한다. 그 후에 해당 도시의 날씨를 검색해야 한다.
   **Action**: `search("city of last Super Bowl")`
1. **Observation**: 검색 결과, 마지막 슈퍼볼은 "Las Vegas"에서 열렸다고 나온다.
1. **Thought**: 이제 도시를 알았으니, Las Vegas의 현재 날씨를 검색해야 한다.
   **Action**: `get_weather("Las Vegas")`
1. **Observation**: 날씨 API 결과, 현재 날씨는 "맑음, 25°C" 이다.
1. **Thought**: 필요한 정보를 모두 얻었다. 사용자에게 최종 답변을 할 수 있다.
   **Answer**: 마지막 슈퍼볼이 열린 Las Vegas의 현재 날씨는 맑고 25°C입니다.

______________________________________________________________________

## 4. 예상 면접 질문 및 모범 답안

### Q1. ReAct와 단순 RAG의 차이점은 무엇인가요?

**A.** 단순 RAG는 **'한 번의 검색과 한 번의 답변'** 으로 끝나는 정적인 프로세스인 반면, ReAct는 **'여러 번의 검색과 추론'** 이 가능하고 동적인 프로세스입니다. ReAct 에이전트는 첫 검색 결과가 만족스럽지 않으면, 새로운 검색어로 다시 검색하는 등 스스로 판단하고 행동을 반복할 수 있지만, 단순 RAG는 그럴 수 없습니다.

**\[추가 설명\]**

- **단순 RAG (Retrieval-Augmented Generation)**:
  - **워크플로우**: 1) 사용자의 초기 질문으로 문서를 검색한다. 2) 검색된 문서의 내용만을 바탕으로 답변을 생성한다. 이것으로 끝이다.
  - **비유**: 책상 위에 주어진 참고자료만으로 답안지를 작성하는 '오픈북 테스트'. 도서관에 다시 갈 수 없습니다.
  - **한계**: 첫 검색 결과가 부실하면, 최종 답변의 품질도 낮을 수밖에 없습니다. 스스로 문제를 해결할 능력이 없습니다.
- **ReAct**:
  - **워크플로우**: 1) 질문으로 도구(검색)를 사용한다. 2) 결과를 관찰하고, 추가 정보가 필요한지 '생각'한다. 3) 필요하다면, 새로운 질문으로 다시 도구를 사용하는 등 행동을 반복한다.
  - **비유**: 궁금한 점이 생기면 도서관에 가서 책을 찾아보고(행동), 읽다가(관찰) 더 궁금한 점이 생기면(생각), 다른 책을 또 찾아보는 '실제 연구 과정'과 같습니다.

### Q2. 도구(Tool)가 실패하거나 잘못된 답변을 줄 때, 시스템의 견고성을 어떻게 확보하나요?

**A.** **사전 예방**과 **사후 복구** 두 가지 측면에서 접근합니다. 사전에는 신뢰할 수 있는 도구를 사용하고 입출력 값을 검증하며, 사후에는 **재시도(Retry), 대체 도구(Fallback), 그리고 자기 수정(Reflexion)** 과 같은 에러 핸들링 로직을 오케스트레이션 레이어에 구현하여 견고성을 확보합니다.

**\[추가 설명\]**

1. **사전 예방 (Prevention)**:
   - **도구 품질**: 안정성이 검증된 API를 사용하고, 도구의 입출력 스키마를 명확히 정의합니다.
   - **입출력 검증**: 도구 호출 전에 파라미터가 유효한지 확인하고, 도구의 응답이 예상된 스키마와 일치하는지 검증합니다. (예: 날씨 API가 JSON 대신 HTML을 반환하면 실패로 간주)
1. **사후 복구 (Recovery)**:
   - **재시도와 백오프 (Retry with Backoff)**: 일시적인 네트워크 오류에 대비해, 몇 초간의 간격을 두고 2~3회 자동으로 재시도합니다.
   - **대체 도구 (Fallback Tools)**: 만약 구글 검색이 실패하면, 빙 검색을 대신 사용하도록 대체 경로를 설정합니다.
   - **자기 수정 (Reflexion)**: 가장 발전된 방식으로, 에이전트가 실패를 '관찰'하고, "왜 실패했을까?"를 '생각'한 뒤, 다른 '행동'을 취하도록 합니다. (예: 검색 결과가 없다는 관찰에, 검색어를 바꿔서 다시 검색하는 행동)
1. **안전 장치 (Guardrails)**:
   - **타임아웃**: 특정 도구가 무한정 응답을 기다리지 않도록 시간제한을 설정합니다.
   - **예산**: 총 도구 호출 횟수나 비용 한도를 설정하여 무한 루프와 과도한 비용을 방지합니다.

### Q3. Observation(관찰) 결과를 어떻게 요약하고 정형화하여 다음 Thought(생각)에 반영하나요?

**A.** 원본 Observation(예: 웹페이지 전체 HTML)은 너무 길고 노이즈가 많으므로, **'요약기(Summarizer)' 모듈을 통해 다음 행동 계획에 필요한 핵심 정보만 추출**하여 정형화된 형태로 가공한 뒤, 컨텍스트에 반영합니다. 이 요약기 또한 LLM을 사용하는 경우가 많습니다.

**\[추가 설명\]**

- **문제점**: 도구의 원본 출력(raw output)은 수천 토큰에 달할 수 있습니다. 이를 그대로 다음 Thought의 입력으로 사용하면, 컨텍스트 창이 금방 가득 차고, LLM이 중요한 정보를 놓치게 되며, 비용이 증가합니다.
- **해결책 (요약/파싱 모듈)**:
  1. **파싱 (구조화된 데이터)**: API가 반환한 JSON과 같이 구조화된 데이터의 경우, 필요한 필드(예: 날씨 데이터에서 `온도`, `상태` 필드)만 추출합니다.
  1. **요약 (비구조화된 데이터)**: 웹페이지 내용과 같이 비구조화된 텍스트의 경우, LLM을 사용하여 목표 지향적인 요약을 수행합니다. 이때 프롬프트는 `"사용자의 목표는 [목표]이고, 방금 [행동]을 수행했다. 다음 단계를 위해 아래 텍스트에서 핵심 정보만 추출해줘." ` 와 같이 매우 구체적이어야 합니다.
  1. **정형화**: 요약된 결과는 일관성 있는 형식(예: `관찰: 가격은 99,000원이며, 재고 있음.`)으로 정리하여, LLM이 다음 Thought를 생성할 때 쉽게 이해하고 활용할 수 있도록 합니다.
- **기대 효과**: 이 과정은 에이전트의 컨텍스트가 불필요한 정보로 오염되는 것을 막는 '필터' 역할을 합니다. 다음 Thought를 위한 입력이 깨끗하고 밀도 높은 정보로 구성되므로, 에이전트의 계획 수립 능력이 향상됩니다.

______________________________________________________________________

## 5. 더 읽어보기 (Further Reading)

- [ReAct: Synergizing Reasoning and Acting in Language Models](https://arxiv.org/abs/2210.03629)
- [A Practical Guide to Building Agents (OpenAI)](/docs/references/openai/a-practical-guide-to-building-agents-3.pdf)
- image: https://peterroelants.github.io/posts/react-repl-agent/

______________________________________________________________________

## 6. See also

- [도구 스키마 및 프로토콜](../5-9-%EB%B3%B4%EC%95%88-and-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C/tool-schemas-jsonrpc-openapi.md)
- [메모리 아키텍처 및 RAG](../5-2-%EB%A9%94%EB%AA%A8%EB%A6%AC-and-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8-%EA%B4%80%EB%A6%AC/memory-architecture.md)
