---
title: '오케스트레이션 & 워크플로우 관리: 멀티-에이전트, 라우팅, 신뢰성 패턴'
date: '2025-10-29'
tags: [Agentic AI, AgentOps, Orchestration, Workflow, LangGraph]
difficulty: hard
---

# 오케스트레이션 & 워크플로우 관리

## 1. 핵심 개념 (Core Concept)

오케스트레이션은 여러 에이전트와 도구가 포함된 복잡한 작업을 안정적으로 수행하기 위한 **중앙 관제 시스템**입니다. 이는 마치 오케스트라의 지휘자처럼, 각 연주자(에이전트/도구)에게 언제 무엇을 연주할지 지시하고, 전체 흐름을 조율하며, 문제가 발생했을 때 대처하는 역할을 합니다. 워크플로우를 상태 머신(State Machine)이나 방향성 비순환 그래프(DAG)로 명확히 정의하고, 그 위에 재시도, 서킷 브레이커 등 신뢰성 패턴을 적용하는 것이 핵심입니다.

*Note: 아래 다이어그램을 위한 이미지를 `docs/images/agent-orchestration-diagram.png` 에 추가해주세요.*
![Agent Orchestration Diagram](../../images/agent-orchestration-diagram.png)

______________________________________________________________________

## 2. 왜 오케스트레이션이 필요한가?

단순한 ReAct 루프는 하나의 LLM과 몇 개의 도구로 구성된 간단한 작업에는 효과적입니다. 하지만 아래와 같은 복잡한 시나리오에서는 금방 한계에 부딪힙니다.

- **멀티-스텝 작업**: 여러 단계를 거쳐야 하는 작업 (예: 리서치 → 초안 작성 → 리뷰 → 수정)
- **멀티-에이전트 협업**: 여러 전문 에이전트가 협력해야 하는 작업 (예: 개발자 에이전트, 테스터 에이전트)
- **동적 분기**: 이전 단계의 결과에 따라 다음 행동이 달라져야 하는 경우
- **높은 신뢰성 요구**: 외부 API 호출 실패, LLM의 형식 오류 등 다양한 실패에 대응해야 하는 프로덕션 환경

오케스트레이션 프레임워크(LangGraph, CrewAI 등)는 이러한 복잡성을 관리하기 위한 구조와 패턴을 제공합니다.

______________________________________________________________________

## 3. 주요 설계 패턴

### 3.1 워크플로우 정의: 상태 머신 & DAG

- **상태 머신 (State Machine)**: 시스템이 가질 수 있는 여러 상태(State)와 상태 간의 전이(Transition)를 명확히 정의합니다. (예: `PLANNING` 상태에서 `RETRIEVING` 상태로 전이)
- **DAG (Directed Acyclic Graph)**: 각 작업을 노드(Node)로, 작업 간의 의존성을 엣지(Edge)로 표현합니다. 병렬 실행이 가능한 작업을 명확히 보여주는 장점이 있습니다.

### 3.2 라우팅 (Routing)

- **인텐트 라우터**: 사용자의 초기 입력을 분석하여, 가장 적합한 워크플로우나 에이전트에게 작업을 전달하는 '교통 경찰' 역할을 합니다.
- **툴 라우터**: 워크플로우의 특정 단계에서, 현재 상태에 가장 적합한 도구를 선택합니다. (예: '요약' 단계에서는 `summarizer_tool`, '검색' 단계에서는 `search_tool` 선택)

### 3.3 신뢰성 패턴 (Reliability Patterns)

- **재시도 (Retry)**
  - **문제**: 일시적인 네트워크 오류로 도구 호출이 실패할 수 있습니다.
  - **해결**: 지수 백오프(Exponential Backoff) 전략을 사용하여, 실패 시 잠시 기다렸다가 몇 차례 더 시도합니다.
- **멱등성 (Idempotency)**
  - **문제**: 재시도 과정에서 동일한 외부 API가 여러 번 호출되어, 결제가 두 번 되거나 티켓이 두 개 생성될 수 있습니다.
  - **해결**: 모든 '쓰기' 작업 요청에 고유한 `idempotency_key`를 포함시킵니다. 서버는 이 키를 기록해두고, 동일한 키로 요청이 다시 오면 실제 작업을 재수행하지 않고 첫 번째 성공 응답을 그대로 반환합니다.
- **서킷 브레이커 (Circuit Breaker)**
  - **문제**: 특정 도구 API가 다운되었는데, 시스템이 계속해서 해당 API를 호출하며 자원을 낭비하고 전체 시스템의 지연을 유발합니다.
  - **해결**: 특정 도구에서 에러율이 급증하면, '차단기'가 내려가 해당 도구로의 모든 호출을 일시적으로 막고 즉시 실패 처리합니다. 이는 장애가 다른 시스템으로 전파되는 것을 막아줍니다.
- **사가 패턴 (Saga Pattern)**
  - **문제**: 여러 단계의 외부 상태 변경 작업 중(예: 1.항공권 예약 → 2.호텔 예약 → 3.렌터카 예약), 중간 단계에서 실패하면 시스템의 상태가 일관되지 않게 됩니다. (항공/호텔은 예약됐지만, 렌터카는 예약 안 됨)
  - **해결**: 각 단계에 대한 '보상 트랜잭션(Compensating Transaction)'을 미리 정의합니다. (예: `book_flight`에 대한 `cancel_flight`). 중간에 실패하면, 이미 성공한 이전 단계들의 보상 트랜잭션을 역순으로 실행하여 전체 작업을 원자적인 것처럼 되돌립니다.

______________________________________________________________________

## 4. 예상 면접 질문 및 모범 답안

### Q1. 코디네이터/워커 패턴의 장단점은 무엇인가요?

**A.** **장점**은 중앙의 코디네이터가 전체 작업 흐름을 관리하여 역할 분담이 명확하고 디버깅이 용이하다는 것입니다. **단점**은 모든 통신이 코디네이터를 거치므로 병목 현상이 발생할 수 있고, 코디네이터가 실패하면 전체 작업이 중단되는 단일 실패점(Single Point of Failure)이 된다는 것입니다.

**\[추가 설명\]**
이 패턴은 작업 단계가 명확하고 순차적인 '조립 라인' 같은 프로세스에 매우 효과적입니다. 하지만, 여러 워커가 서로 유기적으로 소통하며 창의적인 결과를 만들어야 하는 작업에는 적합하지 않을 수 있습니다. 더 자세한 내용은 `agent-interaction-and-protocols.md` 문서를 참고하세요.

### Q2. 라우팅은 어느 단계에서 수행되며, 실패 시 어떻게 경로를 변경하나요?

**A.** 라우팅은 크게 **초기 인텐트 라우팅**과 **워크플로우 내 툴 라우팅** 두 단계에서 수행됩니다. 경로 변경은 **정적 폴백(미리 정의된 대체 경로)** 과 **동적 폴백(LLM이 실시간으로 새 경로 제안)** 방식으로 처리할 수 있습니다.

**\[추가 설명\]**

- **라우팅 단계**:
  1. **인텐트 라우팅**: 사용자의 첫 요청이 들어왔을 때, 이 요청의 의도를 파악하여 가장 적합한 워크플로우(예: '단순 질의응답', '예약 처리')로 보내는 '첫 관문' 역할을 합니다.
  1. **툴 라우팅**: 워크플로우가 진행되는 각 단계에서, 현재 상태에 가장 적합한 다음 도구나 에이전트를 선택하는 '교차로' 역할을 합니다.
- **경로 변경 전략**:
  - **정적 폴백**: `try { 구글_검색() } catch { 빙_검색() }` 처럼, 코드에 대체 경로를 명시적으로 하드코딩하는 방식입니다. 예측 가능하고 안정적입니다.
  - **동적 폴백**: 도구 호출이 실패하면, 그 에러 메시지를 LLM에게 전달하며 `"이 도구가 이 에러와 함께 실패했다. 이 문제를 우회하여 원래 목표를 달성할 새로운 계획을 세워라."` 라고 요청하는 방식입니다. 더 유연하고 회복탄력성이 높습니다.

### Q3. 멱등성 키(Idempotency Key)와 사가(Saga) 패턴은 어떤 종류의 작업에 적용해야 하나요?

**A.** **멱등성 키**는 재시도 시에도 **단 한 번만 실행되어야 하는 개별 행동**에 적용합니다. (예: 결제, 사용자 생성). **사가 패턴**은 여러 개의 개별 행동이 모여 하나의 논리적 단위를 이루는 **장기 실행 트랜잭션**에 적용하여, 중간에 실패했을 때 이전 단계들을 되돌리기(보상) 위해 사용합니다. (예: 여행 패키지 예약)

**\[추가 설명\]**

- **멱등성 키 적용 대상**: 외부 시스템의 상태를 변경하는 모든 '쓰기' 작업이 대상입니다. `create_booking`, `charge_credit_card`, `send_invoice` 등이 대표적입니다. `get_weather` 처럼 상태를 변경하지 않는 '읽기' 작업에는 필요 없습니다.
- **사가 패턴 적용 대상**: 여러 개의 독립적인 트랜잭션으로 구성된 비즈니스 프로세스에 적용됩니다. 예를 들어, '항공권 예약', '호텔 예약', '렌터카 예약'은 각각 독립된 시스템에 대한 트랜잭션이지만, 비즈니스적으로는 '여행 예약'이라는 하나의 논리적 단위입니다. 이 중 하나라도 실패하면, 이미 성공한 다른 예약들을 취소(보상)하여 데이터 정합성을 맞춰야 합니다.

______________________________________________________________________

## 5. See also

- [에이전트 상호작용 및 프로토콜](../5-1-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%84%A4%EA%B3%84/agent-interaction-and-protocols.md)
- [평가 및 모니터링 (운영)](./evaluation-monitoring-ops.md)
